/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/
/**
 * @file mesh2vol.cpp
 * @ingroup converters
 *
 * @date 2016/09/28
 *
 *
 *
 * This file is part of the DGtalTools.
 */

///////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <fstream>
#include <chrono>

#include "DGtal/shapes/MeshVoxelizer.h"
#include "DGtal/kernel/sets/CDigitalSet.h"
#include "DGtal/kernel/domains/HyperRectDomain.h"
#include "DGtal/io/readers/MeshReader.h"
#include "DGtal/io/Display3D.h"
#include "DGtal/io/writers/GenericWriter.h"
#include "DGtal/images/ImageContainerBySTLVector.h"
#include <boost/program_options/options_description.hpp>
#include <boost/program_options/parsers.hpp>
#include <boost/program_options/variables_map.hpp>

using namespace std;
using namespace DGtal;


///////////////////////////////////////////////////////////////////////////////
namespace po = boost::program_options;

/**
 @page mesh2vol
 @brief Convert a mesh file into a 26-separated or 6-separated voxelization in a given resolution grid.

@b Usage: mesh2vol [input]

@b Allowed @b options @b are:

@code
  -h [ --help ]                   display this message
  -i [ --input ] arg              mesh file (.off)
  -o [ --output ] arg             filename of ouput voxelization file (.off)
                                  (auto-generated by argument values if empty)
  -s [ --separation ] arg (=6)    voxelization 6-separated or 26-separated.
  -d [ --domainSize ] arg (=64)   digitization domain size.
  -f [ --scaleFactor ] arg (=1.0) scale factor to apply to the mesh

@endcode

@b Example:
@code
  $ mesh2vol -i ${DGtal}/examples/samples/tref.off --separation 26 --resolution 256
@endcode

@see mesh2vol.cpp

*/

template< unsigned int SEP >
void voxelizeAndExport(const std::string inputFilename,
                       const std::string outputFilename,
                       const unsigned int resolution,
                       const double scaleFactor)
{

  using Space3Dint = SpaceND<3>;
  using Domain   = HyperRectDomain<Space3Dint>;
  using PointR3  = PointVector<3, double>;
  using PointZ3  = PointVector<3, int>;

  trace.info() << "Reading input file: " << inputFilename;

  Mesh<PointR3> inputMesh;

  unsigned int base = resolution/2; // move center of digital set to (0;0;0)
  Domain aDomain( PointZ3(-base, -base, -base),
                  PointZ3( base,  base,  base) );

  MeshReader<PointR3>::importOFFFile(inputFilename.c_str(), inputMesh);
  trace.info() << " [done]" << std::endl;
  trace.info() << "Voxelization " << SEP << "-separated ; " << resolution << "^3 ";

  //Digitization step
  DigitalSetBySTLSet<Domain> mySet(aDomain);
  MeshVoxelizer<DigitalSetBySTLSet<Domain>, SEP> aVoxelizer;
  double factor = scaleFactor;
  if(factor == 1.0)
    factor = resolution / inputMesh.getBoundingBox().second[0];
  
  auto start = std::chrono::high_resolution_clock::now();
  aVoxelizer.voxelize(mySet, inputMesh, factor);
  auto end = std::chrono::high_resolution_clock::now();
  auto diff = end - start;

  trace.info() << " [done] (" << std::chrono::duration <double, std::milli> (diff).count() << " ms)" << std::endl;

  // Export the digital set to a vol file
  trace.info()<<aDomain<<std::endl;
  ImageContainerBySTLVector<Domain, unsigned char> image(aDomain);
  for(auto p: mySet)
  {
    trace.info()<<"Adding "<<p<<std::endl;
    image.setValue(p, 128);
  }
  image >> outputFilename.c_str();
}

int main( int argc, char** argv )
{ 
  // parse command line ----------------------------------------------
  po::options_description general_opt("\nAllowed options are");
  general_opt.add_options()
    ("help,h", "display this message")
    ("input,i", po::value<std::string>(), "mesh file (.off) " )
    ("output,o", po::value<std::string>(), "filename of ouput volumetric file (Vol,PGM3D,..).")
    ("separation,s", po::value<unsigned int>()->default_value(6), "voxelization 6-separated or 26-separated." )
    ("scaleFactor,f", po::value<double>()->default_value(1.0), "scale factor to apply to the mesh." )
    ("domainSize,d", po::value<unsigned int>()->default_value(64), "digitization domain size." );

  bool parseOK=true;
  po::variables_map vm;
  try {
    po::store(po::parse_command_line(argc, argv, general_opt), vm);
  } catch(const std::exception& ex) {
    parseOK=false;
    trace.info() << "Error checking program options: " << ex.what() << endl;
  }

  po::notify(vm);

  if(!parseOK || vm.count("help") || argc < 1)
  {
    std::cout << "Usage: " << argv[0] << " -i [input]\n"
              << "Convert a mesh file into a 26-separated or 6-separated volumetric voxelization in a given resolution grid."
              << general_opt << "\n";
    std::cout << "Example:\n"
              << "mesh2vol -i ${DGtal}/examples/samples/tref.off --separation 26 --resolution 256 \n";
    return -1;
  }
  
  if( !vm.count("input") )
  {
    trace.error() << " Input filename is needed to be defined" << endl;
    return -1;
  }
  
  if( vm["separation"].as<unsigned int>() != 6 &&
      vm["separation"].as<unsigned int>() != 26 )
  {
    trace.error() << " Separation should be 6 or 26" << endl;
    return -1;
  }

  unsigned int separation = vm["separation"].as<unsigned int>();
  unsigned int resolution = vm["domainSize"].as<unsigned int>();
  string inputFilename = vm["input"].as<std::string>();
  string outputFilename;
  double scaleFactor = vm["scaleFactor"].as<double>();
  
  if( vm.count("output") )
    outputFilename = vm["output"].as<std::string>();
  else
  {
    trace.error()<<"Missing output parameter '--output'"<<std::endl;
    return -1;
  }
  
  
  if(separation == 6)
    voxelizeAndExport<6>(inputFilename, outputFilename, resolution, scaleFactor);
  else if(separation == 26)
    voxelizeAndExport<26>(inputFilename, outputFilename, resolution, scaleFactor);

  return 0;
}

